# 实现 Effect

> Metadata:
>
> Date: 2022/11/2 22:48

## 本篇内容关键性思想

- happy path
- 任务拆分

## Effect 是什么？

- 本质上，Effect 就是一些可执行函数的代名词
- 而 `reactive.ts` 文件中的 `effect` 方法则是我们用来收集 Effect 的入口
- 为了扩展我们对 Effect 操作的能力，方便后续 API 设计，我们会创建一个概念叫做 `ReactiveEffect`，这个类将被用来操作收集到的 Effect，在现阶段，我们只会使用到它的 run 方法

## Effect 为什么第一个学它？

- 我们知道 vue 框架的主要价值是实现用数据去驱动视图，而 Effect 作为响应式最核心的概念，作为数据的入口，是承载驱动任务的关键，只有实现它之后，我们才可以在响应式的基础上开展后续的工作

## Effect 是怎么被一步步实现的？

### 总结整个通用流程大致是：

- 设计 happy path 单元测试
- 根据 happy path 拆解必要任务
- 逐个实现拆解出来的任务

### 以 Effect 的实现为例

- 根据 vue 的自有 API，我们可以编写出 effect 的核心测试流程，这种流程也被称为 happy path
- 我们发现，要让该 happy path 通过测试至少需要实现 effect 和 reactive 两个函数，effect 用来做收集的入口，而 reactive 用来代理对象（这里还没有涉及到响应式）于是必要任务就是分别实现这两个函数
- 进一步的，我们希望在代理对象的值发生变更后，Effect 被执行，这个行为叫做响应式。分析该行为后，我们发现，要实现此效果，我们需要借助 proxy 的代理能力，在代理对象被 get 和 set 时分别做依赖收集和依赖触发

## 什么是 `happy path` ，它的价值主要体现在哪？

- `happy path` 指的是最核心的代码流程
- 它的价值在我看来主要体现在
  - 它将使 API 的设计过程，变得由易到难，由简单到复杂，我们将尽可能保持一个轻松的心态去开发
  - 它将使我们可以站在 API 设计者的角度去看待问题，而不是纯粹的用户心态
  - 这种小步走的方式更有助于我们理清思路，在每个阶段保留更充分的思考，并且写出更高质量的代码
  - 将一个测试从不通过变为通过是一种正向反馈，有助于激发编程的兴趣，而 happy path 简单易过，让人可以快速进入编码状态

## 任务拆分，小步走思想

- 单独把这个点拎出来写，是因为它对于没有接触过 TDD 的程序员是一种冲击。以我个人为例，在接触这种思想之前，我是偏向于结果主义的，也就是会更加急于去跑通一个大而全的功能，在细节的设计上则放任粗糙，于是反而不能提升开发的效率，还容易陷入一种烦躁的情绪。
- TDD 思想呢，并没有要求我们放弃结果主义，反而它会与之更加的契合，它将目标从大变为了小，将成就从不可见变为可见的测试通过

## 依赖收集？触发依赖？它们做了些什么事？

- 数据要驱动视图，很显然，这是后话。但我们可以预测到的是，响应式系统中，必然有一个收集和通知的过程
- 收集是为了将代理对象各个属性所对应的数据操作存储起来，这些被存储起来的操作就是依赖，也是上文提到的 Effect
- 当代理对象触发某个 key 的 set 时，该 key 所对应的值需要在此时发生变更，但是所有依赖该响应式的值也应当同步变更，这时我们就需要依次执行此前收集的依赖，也就是该 key 所对应的各种数据操作

## 浅聊 effect 的 stop 实现

- 在实现 stop 的过程中，我们通过传入一个 runner 去反查出该 runner 对应的 effect，以及该 effect 所对应的一系列 deps，这个过程用到了反向的收集，而这种灵活的思想是非常值得品味的

## 优化 stop

- stop 存在一个边缘情况，会导致清空依赖后，再次将依赖收集。为了处理这种 case，我们需要给依赖收集的过程加一把锁，而这把锁的状态则取决于响应式对象是否已经被 stop，如果没有，我们让其正常收集，如果已经被 stop，则只执行 fn（也就是只保持响应式对象值的更新），而不触发依赖的收集，这样在后续进行 set 的时候，就无法触发依赖，从而确保 stop 的效果

## 补充阅读

- [Proxy 和 Reflec 扫盲](https://github.com/hlyiww/learn-mini-vue/issues/1)
